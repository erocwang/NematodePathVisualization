{"version":3,"sources":["PathFindingVisualizer/Node/Node.jsx","PathFindingVisualizer/Neuron/Neuron.jsx","Algorithms/Nematode.js","PathFindingVisualizer/PathFindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isEnd","isWall","onMouseDown","onMouseEnter","onMouseUp","coloring","id","className","Component","Neuron","tag","type","nematode","grid","startNode","endNode","node","dist","Math","abs","updateDist","visitedNodesInOrder","curNode","count","getNeighbors","neighbors","neighborDists","totalDist","length","r","random","i","push","dir","neighborDist","weights","nextRow","nextCol","pow","curneighborDists","PathFindingVisualizer","circuit","mouseIsPressed","getInitialGrid","getInitialCircuit","setState","newGrid","getNewGridWithWallToggled","document","getElementById","visualizeNematode","animateNematode","console","log","prev","setTimeout","class","onClick","floodVisualize","reset","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","colIdx","neuron","neuronIdx","createNode","Infinity","currentRow","createNeuron","col_1","col_3","slice","newNode","App","useState","vizKey","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.11fb6941.chunk.js","sourcesContent":["import React , {Component} from 'react';\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {}; \r\n    }\r\n\r\n    render() {\r\n        const {\r\n            row, \r\n            col, \r\n            isStart,\r\n            isEnd,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n        } = this.props; \r\n        const coloring = isEnd ? 'node-end' : isStart ? 'node-start' : isWall ? 'node-wall' : '';\r\n        return (\r\n            <div \r\n                id = {`node-${row}-${col}`}\r\n                className={`node ${coloring}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}\r\n            ></div> \r\n        );\r\n    }\r\n}","import React , {Component} from 'react';\r\nimport './Neuron.css';\r\n\r\nexport default class Neuron extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {}; \r\n    }\r\n\r\n    render() {\r\n        const {\r\n            tag,\r\n        } = this.props; \r\n        const type = tag==='AWC' ? 'neuron' : 'inter-neuron';\r\n        return (\r\n            <div \r\n                id = {`neuron-${tag}`}\r\n                className = {`${type}`}>\r\n                {tag}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n//yo the css subclasses have to be underneath the higher ones ","//nematode algorithm for choosing path \r\nexport function nematode(grid,startNode,endNode) {\r\n    updateDist(grid,endNode); \r\n    const visitedNodesInOrder = [];\r\n    var curNode = startNode;  \r\n    var count = 1000; \r\n    while((curNode!==endNode) && count) {   \r\n        count--; \r\n        const [neighbors,neighborDists] = getNeighbors(curNode,grid,endNode);\r\n        const totalDist = neighborDists[neighborDists.length-1]; \r\n        const r = Math.random()*totalDist; \r\n        for(let i=0; i<neighborDists.length; i++) {\r\n            if(r <= neighborDists[i]) {\r\n                curNode = neighbors[i];\r\n                visitedNodesInOrder.push(curNode); \r\n                break; \r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder; \r\n}\r\n\r\n//return a list of nodes in ascending distance order\r\n//return a list of prefix sums of node distances in reverse order \r\nfunction getNeighbors(node,grid,endNode) {\r\n    const neighbors = []; \r\n    const neighborDists = []; \r\n    const dir = [[1,0],[-1,0],[0,-1],[0,1]];\r\n    const expo = 10; \r\n    var neighborDist = 0; \r\n    var weights = 0; \r\n    for(let i = 0; i < 4; i++) {\r\n        const nextRow = node.row + dir[i][0]; \r\n        const nextCol = node.col + dir[i][1]; \r\n        if(nextRow >= 0 && nextRow <= grid.length-1 && nextCol >=0 && nextCol <= grid[0].length-1 && !grid[nextRow][nextCol].isWall) {\r\n            neighbors.push(grid[nextRow][nextCol]); \r\n            neighborDist += Math.pow(grid[nextRow][nextCol].dist,expo); \r\n            if(grid[nextRow][nextCol].dist>node.dist) {\r\n                neighborDists.push((50-grid[nextRow][nextCol].dist)/2); \r\n            }\r\n            else {\r\n                neighborDists.push((50-grid[nextRow][nextCol].dist)); \r\n            }\r\n            weights += neighborDists[neighborDists.length-1]; \r\n        }\r\n    }\r\n    var curneighborDists = 0; \r\n    for(let i=0; i<neighbors.length; i++) {\r\n        curneighborDists += neighborDists[i]/weights*neighborDist; \r\n        neighborDists[i] = (curneighborDists); \r\n    }\r\n    //console.log(neighbors);\r\n    return [neighbors,neighborDists]; \r\n}\r\n\r\n//sort nodes by distance in ascending order \r\nfunction sortByDist(neighbors) {\r\n    neighbors.sort((nodeA, nodeB) => nodeA.dist - nodeB.dist); \r\n}\r\n\r\n//initally set the distances of all nodes \r\nfunction updateDist(grid,endNode) {\r\n    for(const row of grid) {\r\n        for(const node of row) {\r\n            node.dist = Math.abs(endNode.row-node.row) + Math.abs(endNode.col-node.col);\r\n        }\r\n    }\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport Neuron from './Neuron/Neuron';\r\nimport {nematode} from '../Algorithms/Nematode'; \r\n\r\nimport './PathFindingVisualizer.css';\r\n\r\nconst START_ROW = 10; \r\nconst START_COL = 10; \r\nconst END_ROW = 10; \r\nconst END_COL = 40; \r\n\r\nexport default class PathFindingVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            circuit: [], \r\n            mouseIsPressed: false, \r\n        }; \r\n    }\r\n\r\n    componentDidMount() {\r\n        const grid = getInitialGrid(); \r\n        const circuit = getInitialCircuit(); \r\n        this.setState({grid,circuit});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid, mouseIsPressed: true});\r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n    }\r\n    \r\n    handleMouseUp() {\r\n        this.setState({mouseIsPressed: false});\r\n    }\r\n\r\n    reset() {\r\n        for (let row = 0; row < 20; row++) {\r\n            for (let col = 0; col < 50; col++) {\r\n                if((row!==START_ROW || col!==START_COL) && (row!==END_ROW || col!==END_COL)) {\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                }\r\n            }\r\n        }\r\n        document.getElementById(`neuron-AWC`).className = 'neuron';\r\n        document.getElementById(`neuron-AIB`).className = 'inter-neuron';\r\n        document.getElementById(`neuron-AIY`).className = 'inter-neuron';\r\n    }\r\n\r\n    floodVisualize() {\r\n        for(let i=0; i<10; i++) {\r\n            this.visualizeNematode(); \r\n        }\r\n    }\r\n\r\n    visualizeNematode() {\r\n        const {grid} = this.state; \r\n        const startNode = grid[START_ROW][START_COL]; \r\n        const endNode = grid[END_ROW][END_COL]; \r\n        const visitedNodesInOrder = nematode(grid,startNode,endNode);\r\n        this.animateNematode(visitedNodesInOrder);  \r\n    }\r\n\r\n    animateNematode(visitedNodesInOrder) {\r\n        //for(let i=visitedNodesInOrder.length-1; i>=0; i--) {\r\n        for(let i=0; i<visitedNodesInOrder.length-1; i++) {\r\n            const node = visitedNodesInOrder[i];\r\n            console.log(i)\r\n            const prev = i===0 ? 1000 : visitedNodesInOrder[i-1].dist; \r\n            setTimeout(() => {\r\n                if(node.row!==START_ROW || node.col!==START_COL) document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                if(node.dist > prev) {\r\n                    document.getElementById(`neuron-AWC`).className = 'neuron green';\r\n                    document.getElementById(`neuron-AIB`).className = 'inter-neuron red';\r\n                    document.getElementById(`neuron-AIY`).className = 'inter-neuron off';\r\n                }\r\n                else {\r\n                    document.getElementById(`neuron-AWC`).className = 'neuron off';\r\n                    document.getElementById(`neuron-AIB`).className = 'inter-neuron off';\r\n                    document.getElementById(`neuron-AIY`).className = 'inter-neuron blue';\r\n                }\r\n            }, 50 * (i+1) - 50); \r\n            setTimeout(() => {\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-seen';\r\n            }, 50 * (i+1) - 25); \r\n        }\r\n    }\r\n\r\n    render() {\r\n        const {grid,circuit,mouseIsPressed} = this.state; \r\n        return (\r\n            <>\r\n            <div className = \"back\">\r\n            <div className = \"navigation\"> \r\n                <button class = \"button1\" onClick={() => this.visualizeNematode()}>\r\n                    Visualize Nematode\r\n                </button>\r\n                    <button class = \"button1\" onClick={() => this.floodVisualize()}>\r\n                        Flood!\r\n                    </button>\r\n                    <button class = \"button1\" onClick={() => this.reset()}>\r\n                        Reset \r\n                    </button>\r\n            </div> \r\n            <div className = \"grid\"> \r\n                {grid.map((row,rowIdx) => {\r\n                    return <div key={rowIdx}>\r\n                        {row.map((node,nodeIdx) => {\r\n                            const {row,col,isStart,isEnd,isWall} = node; \r\n                            return (\r\n                                <Node\r\n                                key = {nodeIdx}\r\n                                row = {row}\r\n                                col = {col}\r\n                                isStart = {isStart}\r\n                                isEnd = {isEnd}\r\n                                isWall={isWall}\r\n                                mouseIsPressed={mouseIsPressed}\r\n                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                onMouseEnter={(row, col) =>\r\n                                  this.handleMouseEnter(row, col)\r\n                                }\r\n                                onMouseUp={() => this.handleMouseUp()}\r\n                                ></Node>\r\n                            );\r\n                        })}\r\n                    </div> \r\n                })}\r\n            </div> \r\n            <div className = \"circuit\"> \r\n                {circuit.map((col,colIdx) => {\r\n                    return <div key={colIdx} className=\"container\">\r\n                        {col.map((neuron,neuronIdx) => {\r\n                            const {tag} = neuron;\r\n                            return (\r\n                                <Neuron \r\n                                key = {neuronIdx}\r\n                                tag = {tag}\r\n                                ></Neuron> \r\n                            );\r\n                        })}\r\n                    </div>\r\n                })}\r\n            </div>\r\n            </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nconst createNode = (row,col) => {\r\n    return {\r\n        row, \r\n        col, \r\n        isStart : row === START_ROW && col === START_COL,\r\n        isEnd : row === END_ROW && col === END_COL,  \r\n        dist : Infinity, \r\n    };\r\n};\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 50; col++) {\r\n        currentRow.push(createNode(row, col));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\nconst createNeuron = (tag) => {\r\n    return {\r\n        tag, \r\n    };\r\n};\r\n\r\nconst getInitialCircuit = () => {\r\n    const circuit = []; \r\n    const col_1 = []; \r\n    col_1.push(createNeuron('AWC'));\r\n    const col_3 = []; \r\n    col_3.push(createNeuron('AIB'));\r\n    col_3.push(createNeuron('AIY'));\r\n    circuit.push(col_1);\r\n    circuit.push(col_3); \r\n    return circuit; \r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n\r\n","import React, { useState } from 'react';\nimport './App.css';\nimport PathFindingVisualizer from './PathFindingVisualizer/PathFindingVisualizer';\n\nfunction App() {\n  const [vizKey,setVizKey] = useState(0); \n  const reset = () => {\n    setVizKey(vizKey+1);\n  }\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer key = {vizKey}></PathFindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}